// Generated by Haxe 4.0.1
#include <hxcpp.h>

#ifndef INCLUDED_CollisionDirection
#include <CollisionDirection.h>
#endif
#ifndef INCLUDED_Direction
#include <Direction.h>
#endif
#ifndef INCLUDED_Main
#include <Main.h>
#endif
#ifndef INCLUDED_Unit
#include <Unit.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectContainer
#include <openfl/display/DisplayObjectContainer.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_InteractiveObject
#include <openfl/display/InteractiveObject.h>
#endif
#ifndef INCLUDED_openfl_display_Sprite
#include <openfl/display/Sprite.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_39a55bac71d71c88_8_new,"Unit","new",0xc0a8b996,"Unit.new","Unit.hx",8,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_28_get_speedY,"Unit","get_speedY",0x5830b845,"Unit.get_speedY","Unit.hx",28,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_32_set_speedY,"Unit","set_speedY",0x5bae56b9,"Unit.set_speedY","Unit.hx",32,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_37_get_hitBox,"Unit","get_hitBox",0xf4455ecb,"Unit.get_hitBox","Unit.hx",37,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_42_checkCollisionWithTile,"Unit","checkCollisionWithTile",0xb5304588,"Unit.checkCollisionWithTile","Unit.hx",42,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_59_directionDefinition,"Unit","directionDefinition",0xd0af55e8,"Unit.directionDefinition","Unit.hx",59,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_84_doCollisionWithTile,"Unit","doCollisionWithTile",0xc0d98011,"Unit.doCollisionWithTile","Unit.hx",84,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_110_doCollisionsWithTiles,"Unit","doCollisionsWithTiles",0x610bd789,"Unit.doCollisionsWithTiles","Unit.hx",110,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_129_get_collisionDirection,"Unit","get_collisionDirection",0xf03ce540,"Unit.get_collisionDirection","Unit.hx",129,0x8bc50a9a)
HX_LOCAL_STACK_FRAME(_hx_pos_39a55bac71d71c88_133_get_direction,"Unit","get_direction",0x6180fecc,"Unit.get_direction","Unit.hx",133,0x8bc50a9a)

void Unit_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_8_new)
HXLINE(  17)		this->movingRight = false;
HXLINE(  16)		this->movingLeft = false;
HXLINE(  13)		this->direction = ::Direction_obj::right_dyn();
HXLINE(  12)		this->gravity = ((Float)0.8);
HXLINE(  11)		this->speedY = ((Float)0.0);
HXLINE(  10)		this->speedX = ((Float)0.0);
HXLINE(  22)		super::__construct();
            	}

Dynamic Unit_obj::__CreateEmpty() { return new Unit_obj; }

void *Unit_obj::_hx_vtable = 0;

Dynamic Unit_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Unit_obj > _hx_result = new Unit_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Unit_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x19c29573) {
		if (inClassId<=(int)0x17120186) {
			if (inClassId<=(int)0x0ddfced7) {
				return inClassId==(int)0x00000001 || inClassId==(int)0x0ddfced7;
			} else {
				return inClassId==(int)0x17120186;
			}
		} else {
			return inClassId==(int)0x19c29573;
		}
	} else {
		if (inClassId<=(int)0x3882f6a4) {
			return inClassId==(int)0x1b123bf8 || inClassId==(int)0x3882f6a4;
		} else {
			return inClassId==(int)0x3f2b00af;
		}
	}
}

Float Unit_obj::get_speedY(){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_28_get_speedY)
HXDLIN(  28)		return this->speedY;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Unit_obj,get_speedY,return )

void Unit_obj::set_speedY(Float value){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_32_set_speedY)
HXDLIN(  32)		this->speedY = value;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Unit_obj,set_speedY,(void))

 ::openfl::geom::Rectangle Unit_obj::get_hitBox(){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_37_get_hitBox)
HXDLIN(  37)		return this->hitBox;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Unit_obj,get_hitBox,return )

bool Unit_obj::checkCollisionWithTile(int tileType,Float tileX,Float tileY){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_42_checkCollisionWithTile)
HXDLIN(  42)		bool _hx_tmp;
HXDLIN(  42)		if ((tileType > 0)) {
HXDLIN(  42)			_hx_tmp = (tileType < 5);
            		}
            		else {
HXDLIN(  42)			_hx_tmp = false;
            		}
HXDLIN(  42)		if (_hx_tmp) {
HXLINE(  44)			Float tileWidth = (( (Float)(::Main_obj::sizeWidth) ) / ( (Float)(20) ));
HXLINE(  45)			Float tileHeight = (( (Float)(::Main_obj::sizeHeight) ) / ( (Float)(15) ));
HXLINE(  46)			bool _hx_tmp1;
HXDLIN(  46)			bool _hx_tmp2;
HXDLIN(  46)			bool _hx_tmp3;
HXDLIN(  46)			Float _hx_tmp4 = this->get_x();
HXDLIN(  46)			if (((_hx_tmp4 + (this->get_hitBox()->width / ( (Float)(2) ))) > tileX)) {
HXLINE(  46)				Float _hx_tmp5 = this->get_x();
HXDLIN(  46)				_hx_tmp3 = ((_hx_tmp5 - (this->get_hitBox()->width / ( (Float)(2) ))) < (tileX + tileWidth));
            			}
            			else {
HXLINE(  46)				_hx_tmp3 = false;
            			}
HXDLIN(  46)			if (_hx_tmp3) {
HXLINE(  47)				Float _hx_tmp6 = this->get_y();
HXLINE(  46)				_hx_tmp2 = ((_hx_tmp6 + (this->get_hitBox()->height / ( (Float)(2) ))) > tileY);
            			}
            			else {
HXLINE(  46)				_hx_tmp2 = false;
            			}
HXDLIN(  46)			if (_hx_tmp2) {
HXLINE(  47)				Float _hx_tmp7 = this->get_y();
HXLINE(  46)				_hx_tmp1 = ((_hx_tmp7 - (this->get_hitBox()->height / ( (Float)(2) ))) < (tileY + tileHeight));
            			}
            			else {
HXLINE(  46)				_hx_tmp1 = false;
            			}
HXDLIN(  46)			if (_hx_tmp1) {
HXLINE(  49)				return true;
            			}
            			else {
HXLINE(  52)				return false;
            			}
            		}
            		else {
HXLINE(  55)			return false;
            		}
HXLINE(  42)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Unit_obj,checkCollisionWithTile,return )

 ::CollisionDirection Unit_obj::directionDefinition(Float tileX,Float tileY){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_59_directionDefinition)
HXLINE(  60)		Float tileWidth = (( (Float)(::Main_obj::sizeWidth) ) / ( (Float)(20) ));
HXLINE(  61)		Float tileHeight = (( (Float)(::Main_obj::sizeHeight) ) / ( (Float)(15) ));
HXLINE(  62)		Float up = ((Float)0.0);
HXLINE(  63)		Float down = ((Float)0.0);
HXLINE(  64)		Float left = ((Float)0.0);
HXLINE(  65)		Float right = ((Float)0.0);
HXLINE(  66)		Float left1 = this->get_x();
HXDLIN(  66)		left = ((left1 + (this->get_hitBox()->width / ( (Float)(2) ))) - tileX);
HXLINE(  67)		Float up1 = this->get_y();
HXDLIN(  67)		up = ((up1 + (this->get_hitBox()->height / ( (Float)(2) ))) - tileY);
HXLINE(  68)		Float right1 = this->get_x();
HXDLIN(  68)		right = ((tileX + tileWidth) - (right1 - (this->get_hitBox()->width / ( (Float)(2) ))));
HXLINE(  69)		Float down1 = this->get_y();
HXDLIN(  69)		down = ((tileY + tileHeight) - (down1 - (this->get_hitBox()->height / ( (Float)(2) ))));
HXLINE(  70)		bool _hx_tmp;
HXDLIN(  70)		bool _hx_tmp1;
HXDLIN(  70)		if ((left <= up)) {
HXLINE(  70)			_hx_tmp1 = (left <= right);
            		}
            		else {
HXLINE(  70)			_hx_tmp1 = false;
            		}
HXDLIN(  70)		if (_hx_tmp1) {
HXLINE(  70)			_hx_tmp = (left <= down);
            		}
            		else {
HXLINE(  70)			_hx_tmp = false;
            		}
HXDLIN(  70)		if (_hx_tmp) {
HXLINE(  71)			return ::CollisionDirection_obj::left_dyn();
            		}
            		else {
HXLINE(  72)			bool _hx_tmp2;
HXDLIN(  72)			bool _hx_tmp3;
HXDLIN(  72)			if ((up <= left)) {
HXLINE(  72)				_hx_tmp3 = (up <= right);
            			}
            			else {
HXLINE(  72)				_hx_tmp3 = false;
            			}
HXDLIN(  72)			if (_hx_tmp3) {
HXLINE(  72)				_hx_tmp2 = (up <= down);
            			}
            			else {
HXLINE(  72)				_hx_tmp2 = false;
            			}
HXDLIN(  72)			if (_hx_tmp2) {
HXLINE(  73)				return ::CollisionDirection_obj::up_dyn();
            			}
            			else {
HXLINE(  74)				bool _hx_tmp4;
HXDLIN(  74)				bool _hx_tmp5;
HXDLIN(  74)				if ((right <= left)) {
HXLINE(  74)					_hx_tmp5 = (right <= up);
            				}
            				else {
HXLINE(  74)					_hx_tmp5 = false;
            				}
HXDLIN(  74)				if (_hx_tmp5) {
HXLINE(  74)					_hx_tmp4 = (right <= down);
            				}
            				else {
HXLINE(  74)					_hx_tmp4 = false;
            				}
HXDLIN(  74)				if (_hx_tmp4) {
HXLINE(  75)					return ::CollisionDirection_obj::right_dyn();
            				}
            				else {
HXLINE(  76)					bool _hx_tmp6;
HXDLIN(  76)					bool _hx_tmp7;
HXDLIN(  76)					if ((down <= left)) {
HXLINE(  76)						_hx_tmp7 = (down <= up);
            					}
            					else {
HXLINE(  76)						_hx_tmp7 = false;
            					}
HXDLIN(  76)					if (_hx_tmp7) {
HXLINE(  76)						_hx_tmp6 = (down <= right);
            					}
            					else {
HXLINE(  76)						_hx_tmp6 = false;
            					}
HXDLIN(  76)					if (_hx_tmp6) {
HXLINE(  77)						return ::CollisionDirection_obj::down_dyn();
            					}
            					else {
HXLINE(  79)						return ::CollisionDirection_obj::up_dyn();
            					}
            				}
            			}
            		}
HXLINE(  70)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Unit_obj,directionDefinition,return )

void Unit_obj::doCollisionWithTile( ::CollisionDirection direction,Float tileX,Float tileY){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_84_doCollisionWithTile)
HXLINE(  86)		Float tileWidth = (( (Float)(::Main_obj::sizeWidth) ) / ( (Float)(20) ));
HXLINE(  87)		Float tileHeight = (( (Float)(::Main_obj::sizeHeight) ) / ( (Float)(15) ));
HXLINE(  88)		if (hx::IsEq( this->get_collisionDirection(),::CollisionDirection_obj::up_dyn() )) {
HXLINE(  90)			this->set_y((tileY - (this->get_hitBox()->height / ( (Float)(2) ))));
HXLINE(  91)			this->speedY = ((Float)0.0);
            		}
            		else {
HXLINE(  93)			if (hx::IsEq( this->get_collisionDirection(),::CollisionDirection_obj::down_dyn() )) {
HXLINE(  95)				this->set_y(((tileY + tileHeight) + (this->get_hitBox()->height / ( (Float)(2) ))));
HXLINE(  96)				this->speedY = ((Float)0.0);
            			}
            			else {
HXLINE(  98)				if (hx::IsEq( this->get_collisionDirection(),::CollisionDirection_obj::left_dyn() )) {
HXLINE( 100)					this->set_x((tileX - (this->get_hitBox()->width / ( (Float)(2) ))));
            				}
            				else {
HXLINE( 102)					if (hx::IsEq( this->get_collisionDirection(),::CollisionDirection_obj::right_dyn() )) {
HXLINE( 104)						this->set_x(((tileX + tileWidth) + (this->get_hitBox()->width / ( (Float)(2) ))));
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Unit_obj,doCollisionWithTile,(void))

void Unit_obj::doCollisionsWithTiles(::Array< ::Dynamic> level){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_110_doCollisionsWithTiles)
HXLINE( 111)		Float tileWidth = (( (Float)(::Main_obj::sizeWidth) ) / ( (Float)(20) ));
HXLINE( 112)		Float tileHeight = (( (Float)(::Main_obj::sizeHeight) ) / ( (Float)(15) ));
HXLINE( 114)		{
HXLINE( 114)			int _g = 0;
HXDLIN( 114)			int _g1 = level->length;
HXDLIN( 114)			while((_g < _g1)){
HXLINE( 114)				_g = (_g + 1);
HXDLIN( 114)				int i = (_g - 1);
HXLINE( 116)				{
HXLINE( 116)					int _g2 = 0;
HXDLIN( 116)					int _g11 = level->__get(i).StaticCast< ::Array< int > >()->length;
HXDLIN( 116)					while((_g2 < _g11)){
HXLINE( 116)						_g2 = (_g2 + 1);
HXDLIN( 116)						int j = (_g2 - 1);
HXLINE( 118)						if (this->checkCollisionWithTile(level->__get(i).StaticCast< ::Array< int > >()->__get(j),(( (Float)(j) ) * tileWidth),(( (Float)(i) ) * tileHeight))) {
HXLINE( 120)							this->collisionDirection = this->directionDefinition((( (Float)(j) ) * tileWidth),(( (Float)(i) ) * tileHeight));
HXLINE( 121)							this->doCollisionWithTile(this->get_collisionDirection(),(( (Float)(j) ) * tileWidth),(( (Float)(i) ) * tileHeight));
            						}
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Unit_obj,doCollisionsWithTiles,(void))

 ::CollisionDirection Unit_obj::get_collisionDirection(){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_129_get_collisionDirection)
HXDLIN( 129)		return this->collisionDirection;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Unit_obj,get_collisionDirection,return )

 ::Direction Unit_obj::get_direction(){
            	HX_STACKFRAME(&_hx_pos_39a55bac71d71c88_133_get_direction)
HXDLIN( 133)		return this->direction;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Unit_obj,get_direction,return )


hx::ObjectPtr< Unit_obj > Unit_obj::__new() {
	hx::ObjectPtr< Unit_obj > __this = new Unit_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Unit_obj > Unit_obj::__alloc(hx::Ctx *_hx_ctx) {
	Unit_obj *__this = (Unit_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Unit_obj), true, "Unit"));
	*(void **)__this = Unit_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Unit_obj::Unit_obj()
{
}

void Unit_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Unit);
	HX_MARK_MEMBER_NAME(speedX,"speedX");
	HX_MARK_MEMBER_NAME(speedY,"speedY");
	HX_MARK_MEMBER_NAME(gravity,"gravity");
	HX_MARK_MEMBER_NAME(direction,"direction");
	HX_MARK_MEMBER_NAME(collisionDirection,"collisionDirection");
	HX_MARK_MEMBER_NAME(movingLeft,"movingLeft");
	HX_MARK_MEMBER_NAME(movingRight,"movingRight");
	HX_MARK_MEMBER_NAME(hitBox,"hitBox");
	 ::openfl::display::Sprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Unit_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(speedX,"speedX");
	HX_VISIT_MEMBER_NAME(speedY,"speedY");
	HX_VISIT_MEMBER_NAME(gravity,"gravity");
	HX_VISIT_MEMBER_NAME(direction,"direction");
	HX_VISIT_MEMBER_NAME(collisionDirection,"collisionDirection");
	HX_VISIT_MEMBER_NAME(movingLeft,"movingLeft");
	HX_VISIT_MEMBER_NAME(movingRight,"movingRight");
	HX_VISIT_MEMBER_NAME(hitBox,"hitBox");
	 ::openfl::display::Sprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Unit_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"speedX") ) { return hx::Val( speedX ); }
		if (HX_FIELD_EQ(inName,"speedY") ) { return hx::Val( speedY ); }
		if (HX_FIELD_EQ(inName,"hitBox") ) { return hx::Val( inCallProp == hx::paccAlways ? get_hitBox() : hitBox ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"gravity") ) { return hx::Val( gravity ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"direction") ) { return hx::Val( direction ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"movingLeft") ) { return hx::Val( movingLeft ); }
		if (HX_FIELD_EQ(inName,"get_speedY") ) { return hx::Val( get_speedY_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_speedY") ) { return hx::Val( set_speedY_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_hitBox") ) { return hx::Val( get_hitBox_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"movingRight") ) { return hx::Val( movingRight ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"get_direction") ) { return hx::Val( get_direction_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"collisionDirection") ) { return hx::Val( inCallProp == hx::paccAlways ? get_collisionDirection() : collisionDirection ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"directionDefinition") ) { return hx::Val( directionDefinition_dyn() ); }
		if (HX_FIELD_EQ(inName,"doCollisionWithTile") ) { return hx::Val( doCollisionWithTile_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"doCollisionsWithTiles") ) { return hx::Val( doCollisionsWithTiles_dyn() ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"checkCollisionWithTile") ) { return hx::Val( checkCollisionWithTile_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_collisionDirection") ) { return hx::Val( get_collisionDirection_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Unit_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"speedX") ) { speedX=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"speedY") ) { speedY=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hitBox") ) { hitBox=inValue.Cast<  ::openfl::geom::Rectangle >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"gravity") ) { gravity=inValue.Cast< Float >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"direction") ) { direction=inValue.Cast<  ::Direction >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"movingLeft") ) { movingLeft=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"movingRight") ) { movingRight=inValue.Cast< bool >(); return inValue; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"collisionDirection") ) { collisionDirection=inValue.Cast<  ::CollisionDirection >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Unit_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("speedX",f1,fe,fa,ba));
	outFields->push(HX_("speedY",f2,fe,fa,ba));
	outFields->push(HX_("gravity",4e,6e,ff,77));
	outFields->push(HX_("direction",3f,62,40,10));
	outFields->push(HX_("collisionDirection",6d,fb,6c,1f));
	outFields->push(HX_("movingLeft",b5,85,00,3e));
	outFields->push(HX_("movingRight",6e,86,81,79));
	outFields->push(HX_("hitBox",78,a5,0f,57));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static hx::StorageInfo Unit_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Unit_obj,speedX),HX_("speedX",f1,fe,fa,ba)},
	{hx::fsFloat,(int)offsetof(Unit_obj,speedY),HX_("speedY",f2,fe,fa,ba)},
	{hx::fsFloat,(int)offsetof(Unit_obj,gravity),HX_("gravity",4e,6e,ff,77)},
	{hx::fsObject /*  ::Direction */ ,(int)offsetof(Unit_obj,direction),HX_("direction",3f,62,40,10)},
	{hx::fsObject /*  ::CollisionDirection */ ,(int)offsetof(Unit_obj,collisionDirection),HX_("collisionDirection",6d,fb,6c,1f)},
	{hx::fsBool,(int)offsetof(Unit_obj,movingLeft),HX_("movingLeft",b5,85,00,3e)},
	{hx::fsBool,(int)offsetof(Unit_obj,movingRight),HX_("movingRight",6e,86,81,79)},
	{hx::fsObject /*  ::openfl::geom::Rectangle */ ,(int)offsetof(Unit_obj,hitBox),HX_("hitBox",78,a5,0f,57)},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Unit_obj_sStaticStorageInfo = 0;
#endif

static ::String Unit_obj_sMemberFields[] = {
	HX_("speedX",f1,fe,fa,ba),
	HX_("speedY",f2,fe,fa,ba),
	HX_("gravity",4e,6e,ff,77),
	HX_("direction",3f,62,40,10),
	HX_("collisionDirection",6d,fb,6c,1f),
	HX_("movingLeft",b5,85,00,3e),
	HX_("movingRight",6e,86,81,79),
	HX_("hitBox",78,a5,0f,57),
	HX_("get_speedY",bb,6e,82,ab),
	HX_("set_speedY",2f,0d,00,af),
	HX_("get_hitBox",41,15,97,47),
	HX_("checkCollisionWithTile",fe,d4,f4,3d),
	HX_("directionDefinition",b2,20,ca,9e),
	HX_("doCollisionWithTile",db,4a,f4,8e),
	HX_("doCollisionsWithTiles",d3,68,86,03),
	HX_("get_collisionDirection",b6,74,01,79),
	HX_("get_direction",16,36,a4,d1),
	::String(null()) };

hx::Class Unit_obj::__mClass;

void Unit_obj::__register()
{
	Unit_obj _hx_dummy;
	Unit_obj::_hx_vtable = *(void **)&_hx_dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_("Unit",a4,f6,82,38);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Unit_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Unit_obj >;
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Unit_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Unit_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

